/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v2/transactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Broadcast raw transaction
         * @description Broadcast raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
         */
        post: operations["post_core_node_transactions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/burn_ops/{burn_height}/{op_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get burn operations
         * @description Get all burn operations of type `op_type` successfully read at `burn_height`. Valid `op_type`s are `peg_in`, `peg_out_request` and `peg_out_fulfill`.
         */
        get: operations["get_burn_ops"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/contracts/interface/{contract_address}/{contract_name}": {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
            };
            cookie?: never;
        };
        /**
         * Get contract interface
         * @description Get contract interface using a `contract_address` and `contract name`
         */
        get: operations["get_contract_interface"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/map_entry/{contract_address}/{contract_name}/{map_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get specific data-map inside a contract
         * @description Attempt to fetch data from a contract data map. The contract is identified with [Stacks Address] and [Contract Name] in the URL path. The map is identified with [Map Name].
         *
         *     The key to lookup in the map is supplied via the POST body. This should be supplied as the hex string serialization of the key (which should be a Clarity value). Note, this is a JSON string atom.
         *
         *     In the response, `data` is the hex serialization of the map response. Note that map responses are Clarity option types, for non-existent values, this is a serialized none, and for all other responses, it is a serialized (some ...) object.
         *
         */
        post: operations["get_contract_data_map_entry"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/contracts/source/{contract_address}/{contract_name}": {
        parameters: {
            query?: {
                /** @description Returns object without the proof field if set to 0 */
                proof?: number;
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
            };
            cookie?: never;
        };
        /**
         * Get contract source
         * @description Returns the Clarity source code of a given contract, along with the block height it was published in, and the MARF proof for the data
         */
        get: operations["get_contract_source"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/contracts/call-read/{contract_address}/{contract_name}/{function_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Call read-only function
         * @description Call a read-only public function on a given smart contract.
         *
         *     The smart contract and function are specified using the URL path. The arguments and the simulated tx-sender are supplied via the POST body in the following JSON format:
         *
         */
        post: operations["call_read_only_function"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/accounts/{principal}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account info
         * @description Get the account data for the provided principal
         *
         *     Where balance is the hex encoding of a unsigned 128-bit integer (big-endian), nonce is a unsigned 64-bit integer, and the proofs are provided as hex strings.
         *
         *     For non-existent accounts, this does not 404, rather it returns an object with balance and nonce of 0.
         *
         */
        get: operations["get_account_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/fees/transaction": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get approximate fees for the given transaction
         * @description Get an estimated fee for the supplied transaction.  This
         *     estimates the execution cost of the transaction, the current
         *     fee rate of the network, and returns estimates for fee
         *     amounts.
         *
         *     * `transaction_payload` is a hex-encoded serialization of
         *       the TransactionPayload for the transaction.
         *     * `estimated_len` is an optional argument that provides the
         *       endpoint with an estimation of the final length (in bytes)
         *       of the transaction, including any post-conditions and
         *       signatures
         *
         *     If the node cannot provide an estimate for the transaction
         *     (e.g., if the node has never seen a contract-call for the
         *     given contract and function) or if estimation is not
         *     configured on this node, a 400 response is returned.
         *     The 400 response will be a JSON error containing a `reason`
         *     field which can be one of the following:
         *
         *     * `DatabaseError` - this Stacks node has had an internal
         *       database error while trying to estimate the costs of the
         *       supplied transaction.
         *     * `NoEstimateAvailable` - this Stacks node has not seen this
         *       kind of contract-call before, and it cannot provide an
         *       estimate yet.
         *     * `CostEstimationDisabled` - this Stacks node does not perform
         *       fee or cost estimation, and it cannot respond on this
         *       endpoint.
         *
         *     The 200 response contains the following data:
         *
         *     * `estimated_cost` - the estimated multi-dimensional cost of
         *       executing the Clarity VM on the provided transaction.
         *     * `estimated_cost_scalar` - a unitless integer that the Stacks
         *       node uses to compare how much of the block limit is consumed
         *       by different transactions. This value incorporates the
         *       estimated length of the transaction and the estimated
         *       execution cost of the transaction. The range of this integer
         *       may vary between different Stacks nodes. In order to compute
         *       an estimate of total fee amount for the transaction, this
         *       value is multiplied by the same Stacks node's estimated fee
         *       rate.
         *     * `cost_scalar_change_by_byte` - a float value that indicates how
         *       much the `estimated_cost_scalar` value would increase for every
         *       additional byte in the final transaction.
         *     * `estimations` - an array of estimated fee rates and total fees to
         *       pay in microSTX for the transaction. This array provides a range of
         *       estimates (default: 3) that may be used. Each element of the array
         *       contains the following fields:
         *         * `fee_rate` - the estimated value for the current fee
         *           rates in the network
         *         * `fee` - the estimated value for the total fee in
         *           microSTX that the given transaction should pay. These
         *           values are the result of computing:
         *           `fee_rate` x `estimated_cost_scalar`.
         *           If the estimated fees are less than the minimum relay
         *           fee `(1 ustx x estimated_len)`, then that minimum relay
         *           fee will be returned here instead.
         *
         *
         *     Note: If the final transaction's byte size is larger than
         *     supplied to `estimated_len`, then applications should increase
         *     this fee amount by:
         *
         *       `fee_rate` x `cost_scalar_change_by_byte` x (`final_size` - `estimated_size`)
         *
         */
        post: operations["post_fee_transaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/fees/transfer": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get estimated fee
         * @description Get an estimated fee rate for STX transfer transactions. This a a fee rate / byte, and is returned as a JSON integer
         */
        get: operations["get_fee_transfer"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Core API info
         * @description Get Core API information
         */
        get: operations["get_core_api_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/pox": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get PoX details
         * @description Get Proof of Transfer (PoX) information. Can be used for Stacking.
         */
        get: operations["get_pox_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/traits/{contract_address}/{contract_name}/{trait_contract_address}/{trait_contract_name}/{trait_name}": {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from.
                 *     If tip == "latest", the query will be run from the latest known tip (includes unconfirmed state).
                 *     If the tip is left unspecified, the stacks chain tip will be selected (only includes confirmed state).
                 *      */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
                /** @description Trait Stacks address */
                trait_contract_address: string;
                /** @description Trait contract name */
                trait_contract_name: string;
                /** @description Trait name */
                trait_name: string;
            };
            cookie?: never;
        };
        /**
         * Get trait implementation details
         * @description Determine whether or not a specified trait is implemented (either explicitly or implicitly) within a given contract.
         */
        get: operations["get_is_trait_implemented"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/constant_val/{contract_address}/{contract_name}/{constant_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get the value of a constant inside a contract
         * @description Attempt to fetch the value of a constant inside a contract. The contract is identified with [Stacks Address] and [Contract Name] in the URL path. The constant is identified with [Constant Name].
         *
         *     In the response, `data` is the hex serialization of the constant value.
         *
         */
        post: operations["get_constant_val"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/block_proposal": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Validate a proposed Stacks block
         * @description Used by stackers to validate a proposed Stacks block from a miner.
         *
         *     **This API endpoint requires a basic Authorization header.**
         *
         */
        post: operations["post_block_proposal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/stacker_set/{cycle_number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch the stacker and signer set information for a given cycle.
         * @description Used to get stacker and signer set information for a given cycle.
         *
         *     This will only return information for cycles started in Epoch-2.5 where PoX-4 was active and subsequent cycles.
         *
         */
        get: operations["get_stacker_set"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/blocks/{block_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch a Nakamoto block
         * @description Fetch a Nakamoto block by its index block hash.
         */
        get: operations["get_block_v3"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/tenures/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch metadata about the ongoing Nakamoto tenure
         * @description Fetch metadata about the ongoing Nakamoto tenure. This information is sufficient to obtain and authenticate the highest complete tenure, as well as obtain new tenure blocks.
         */
        get: operations["get_tenure_info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v3/tenures/{block_id}": {
        parameters: {
            query?: {
                /** @description The block ID hash of the highest block in this tenure that is already known to the caller.  Neither the corresponding block nor any of its ancestors will be served.  This is used to fetch tenure blocks that the caller does not have. */
                stop?: string;
            };
            header?: never;
            path: {
                /** @description The tenure-start block ID of the tenure to query */
                block_id: string;
            };
            cookie?: never;
        };
        /**
         * Fetch a sequence of Nakamoto blocks in a tenure
         * @description Fetch a sequence of Nakamoto blocks in a tenure.  The blocks will be served in order from highest to lowest.  The blocks will be encoded in their SIP-003 wire format, and concatenated together.
         */
        get: operations["get_tenures"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * PostCoreNodeTransactionsError
         * @description GET request that returns transactions
         */
        "post-core-node-transactions-error.schema": {
            /** @description The error */
            error: string;
            /** @description The reason for the error */
            reason: string;
            /** @description More details about the reason */
            reason_data: Record<string, never>;
            /** @description The relevant transaction id */
            txid: string;
        };
        /**
         * ContractInterfaceResponse
         * @description GET request to get contract interface
         */
        "get-contract-interface.schema": {
            /** @description List of defined methods */
            functions: Record<string, never>[];
            /** @description List of defined variables */
            variables: Record<string, never>[];
            /** @description List of defined data-maps */
            maps: Record<string, never>[];
            /** @description List of fungible tokens in the contract */
            fungible_tokens: Record<string, never>[];
            /** @description List of non-fungible tokens in the contract */
            non_fungible_tokens: Record<string, never>[];
        };
        /**
         * MapEntryResponse
         * @description Response of get data map entry request
         */
        "get-contract-data-map-entry.schema": {
            /** @description Hex-encoded string of clarity value. It is always an optional tuple. */
            data: string;
            /** @description Hex-encoded string of the MARF proof for the data */
            proof?: string;
        };
        /**
         * ContractSourceResponse
         * @description GET request to get contract source
         */
        "get-contract-source.schema": {
            source: string;
            publish_height: number;
            proof: string;
        };
        /**
         * ReadOnlyFunctionArgs
         * @description Describes representation of a Type-0 Stacks 2.0 transaction. https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#type-0-transferring-an-asset
         */
        "read-only-function-args.schema": {
            /** @description The simulated tx-sender */
            sender: string;
            /** @description An array of hex serialized Clarity values */
            arguments: string[];
        };
        /**
         * ReadOnlyFunctionSuccessResponse
         * @description GET request to get contract source
         */
        "post-call-read-only-fn.schema": {
            okay: boolean;
            result?: string;
            cause?: string;
        };
        /**
         * AccountDataResponse
         * @description GET request for account data
         */
        "get-account-data.schema": {
            balance: string;
            locked: string;
            unlock_height: number;
            nonce: number;
            balance_proof: string;
            nonce_proof: string;
        };
        /**
         * TransactionFeeEstimateRequest
         * @description POST request for estimated fee
         */
        "post-fee-transaction.schema": {
            transaction_payload: string;
            estimated_len?: number;
        };
        /**
         * TransactionFeeEstimateResponse
         * @description POST response for estimated fee
         */
        "post-fee-transaction-response.schema": {
            estimated_cost_scalar: number;
            cost_scalar_change_by_byte?: number;
            estimated_cost: {
                read_count: number;
                read_length: number;
                runtime: number;
                write_count: number;
                write_length: number;
            };
            estimations?: {
                fee_rate?: number;
                fee?: number;
            }[];
        };
        /**
         * CoreNodeFeeResponse
         * @description GET fee estimates
         */
        "get-fee-transfer.schema": string;
        /**
         * CoreNodeInfoResponse
         * @description GET request that core node information
         */
        "get-info.schema": {
            /** @description identifies the version number for the networking communication, this should not change while a node is running, and will only change if there's an upgrade */
            peer_version: number;
            /** @description is a hash used to identify the burnchain view for a node. it incorporates bitcoin chain information and PoX information. nodes that disagree on this value will appear to each other as forks. this value will change after every block */
            pox_consensus: string;
            /** @description latest bitcoin chain height */
            burn_block_height: number;
            /** @description same as burn_consensus, but evaluated at stable_burn_block_height */
            stable_pox_consensus: string;
            /** @description leftover from stacks 1.0, basically always burn_block_height - 1 */
            stable_burn_block_height: number;
            /** @description is a version descriptor */
            server_version: string;
            /** @description is similar to peer_version and will be used to differentiate between different testnets. this value will be different between mainnet and testnet. once launched, this value will not change */
            network_id: number;
            /** @description same as network_id, but for bitcoin */
            parent_network_id: number;
            /** @description the latest Stacks chain height. Stacks forks can occur independent of the Bitcoin chain, that height doesn't increase 1-to-1 with the Bitcoin height */
            stacks_tip_height: number;
            /** @description the best known block hash for the Stack chain (not including any pending microblocks) */
            stacks_tip: string;
            /** @description the burn chain (i.e., bitcoin) consensus hash at the time that stacks_tip was mined */
            stacks_tip_consensus_hash: string;
            /** @description the latest microblock hash if any microblocks were processed. if no microblock has been processed for the current block, a 000.., hex array is returned */
            unanchored_tip: string;
            /** @description the block height at which the testnet network will be reset. not applicable for mainnet */
            exit_at_block_height: number;
        };
        /**
         * CoreNodePoxResponse
         * @description Get Proof of Transfer (PoX) information
         */
        "get-pox.schema": {
            /** @description The contract identifier for the PoX contract */
            contract_id: string;
            /** @description The first burn block evaluated in this Stacks chain */
            first_burnchain_block_height: number;
            /** @description The latest Bitcoin chain block height */
            current_burnchain_block_height: number;
            /** @description The threshold of stacking participation that must be reached for PoX to activate in any cycle */
            pox_activation_threshold_ustx: number;
            /** @description The fraction of liquid STX that must vote to reject PoX in order to prevent the next reward cycle from activating. */
            rejection_fraction: number;
            /** @description The length in burn blocks of the reward phase */
            reward_phase_block_length: number;
            /** @description The length in burn blocks of the prepare phase */
            prepare_phase_block_length: number;
            /** @description The number of reward slots in a reward cycle */
            reward_slots: number;
            /** @description The current total amount of liquid microstacks. */
            total_liquid_supply_ustx: number;
            /** @description The length in burn blocks of a whole PoX cycle (reward phase and prepare phase) */
            reward_cycle_length: number;
            current_cycle: {
                /** @description The reward cycle number */
                id: number;
                /** @description The threshold amount for obtaining a slot in this reward cycle. */
                min_threshold_ustx: number;
                /** @description The total amount of stacked microstacks in this reward cycle. */
                stacked_ustx: number;
                /** @description Whether or not PoX is active during this reward cycle. */
                is_pox_active: boolean;
            };
            next_cycle: {
                /** @description The reward cycle number */
                id: number;
                /** @description The threshold amount for obtaining a slot in this reward cycle. */
                min_threshold_ustx: number;
                /** @description The total amount of stacked microstacks in this reward cycle. */
                stacked_ustx: number;
                /** @description The minimum amount that can be used to submit a `stack-stx` call. */
                min_increment_ustx: number;
                /** @description The burn block height when the prepare phase for this cycle begins. Any eligible stacks must be stacked before this block. */
                prepare_phase_start_block_height: number;
                /** @description The number of burn blocks until the prepare phase for this cycle starts. If the prepare phase for this cycle already started, this value will be negative. */
                blocks_until_prepare_phase: number;
                /** @description The burn block height when the reward phase for this cycle begins. Any eligible stacks must be stacked before this block. */
                reward_phase_start_block_height: number;
                /** @description The number of burn blocks until this reward phase starts. */
                blocks_until_reward_phase: number;
                /** @description The remaining amount of liquid STX that must vote to reject the next reward cycle to prevent the next reward cycle from activating. */
                ustx_until_pox_rejection: number;
            };
            /**
             * @deprecated
             * @description The active reward cycle number
             */
            reward_cycle_id: number;
            /** @deprecated */
            min_amount_ustx: number;
            /** @deprecated */
            prepare_cycle_length: number;
            /** @deprecated */
            rejection_votes_left_required: number;
            /** @description Versions of each PoX */
            contract_versions: {
                /** @description The contract identifier for the PoX contract */
                contract_id: string;
                /** @description The burn block height at which this version of PoX is activated */
                activation_burnchain_block_height: number;
                /** @description The first reward cycle number that uses this version of PoX */
                first_reward_cycle_id: number;
            }[];
        };
        /**
         * IsTraitImplementedSuccessResponse
         * @description GET request to get trait implementation information
         */
        "get-is-trait-implemented.schema": {
            is_implemented: boolean;
        };
        /**
         * ConstantValResponse
         * @description Response of get constant val request
         */
        "get-constant-val.schema": {
            /** @description Hex-encoded string of clarity value. */
            data: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    post_core_node_transactions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example binary format of 00000000010400bed38c2aadffa348931bcb542880ff79d607afec000000000000000000000000000000c800012b0b1fff6cccd0974966dcd665835838f0985be508e1322e09fb3d751eca132c492bda720f9ef1768d14fdabed6127560ba52d5e3ac470dcb60b784e97dc88c9030200000000000516df0ba3e79792be7be5e50a370289accfc8c9e032000000000000303974657374206d656d6f00000000000000000000000000000000000000000000000000 */
                "application/octet-stream": string;
            };
        };
        responses: {
            /** @description Transaction id of successful post of a raw tx to the node's mempool */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Rejections result in a 400 error */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["post-core-node-transactions-error.schema"];
                };
            };
        };
    };
    get_burn_ops: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description height of the burnchain (Bitcoin) */
                burn_height: number;
                /** @description name of the burnchain operation type */
                op_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Burn operations list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_contract_interface: {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Contract interface */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-contract-interface.schema"];
                };
            };
        };
    };
    get_contract_data_map_entry: {
        parameters: {
            query?: {
                /** @description Returns object without the proof field when set to 0 */
                proof?: number;
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
                /** @description Map name */
                map_name: string;
            };
            cookie?: never;
        };
        /** @description Hex string serialization of the lookup key (which should be a Clarity value) */
        requestBody: {
            content: {
                "application/json": string;
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-contract-data-map-entry.schema"];
                };
            };
            /** @description Failed loading data map */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_contract_source: {
        parameters: {
            query?: {
                /** @description Returns object without the proof field if set to 0 */
                proof?: number;
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-contract-source.schema"];
                };
            };
        };
    };
    call_read_only_function: {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
                /** @description Function name */
                function_name: string;
            };
            cookie?: never;
        };
        /** @description map of arguments and the simulated tx-sender where sender is either a Contract identifier or a normal Stacks address, and arguments is an array of hex serialized Clarity values. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["read-only-function-args.schema"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["post-call-read-only-fn.schema"];
                };
            };
        };
    };
    get_account_info: {
        parameters: {
            query?: {
                /** @description Returns object without the proof field if set to 0 */
                proof?: number;
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address or a Contract identifier (e.g. `SP31DA6FTSJX2WGTZ69SFY11BH51NZMB0ZW97B5P0.get-info`) */
                principal: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-account-data.schema"];
                };
            };
        };
    };
    post_fee_transaction: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "estimated_len": 350,
                 *       "transaction_payload": "021af942874ce525e87f21bbe8c121b12fac831d02f4086765742d696e666f0b7570646174652d696e666f00000000"
                 *     } */
                "application/json": components["schemas"]["post-fee-transaction.schema"];
            };
        };
        responses: {
            /** @description Estimated fees for the transaction */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["post-fee-transaction-response.schema"];
                };
            };
        };
    };
    get_fee_transfer: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-fee-transfer.schema"];
                };
            };
        };
    };
    get_core_api_info: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-info.schema"];
                };
            };
        };
    };
    get_pox_info: {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-pox.schema"];
                };
            };
        };
    };
    get_is_trait_implemented: {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from.
                 *     If tip == "latest", the query will be run from the latest known tip (includes unconfirmed state).
                 *     If the tip is left unspecified, the stacks chain tip will be selected (only includes confirmed state).
                 *      */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
                /** @description Trait Stacks address */
                trait_contract_address: string;
                /** @description Trait contract name */
                trait_contract_name: string;
                /** @description Trait name */
                trait_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-is-trait-implemented.schema"];
                };
            };
        };
    };
    get_constant_val: {
        parameters: {
            query?: {
                /** @description The Stacks chain tip to query from. If tip == latest, the query will be run from the latest known tip (includes unconfirmed state). */
                tip?: string;
            };
            header?: never;
            path: {
                /** @description Stacks address */
                contract_address: string;
                /** @description Contract name */
                contract_name: string;
                /** @description Constant name */
                constant_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["get-constant-val.schema"];
                };
            };
            /** @description Failed to retrieve constant value from contract */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    post_block_proposal: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "block": "00000000000000001f00000000000927c08fb5ae5bf80e39e4168f6a3fddb0407a069d21ee68465e6856393254d2a66194f44bb01070666d5effcfb2436e209a75878fe80a04b4258a8cd34ab97c38a8dde331a2a509dd7e4b90590726866172cc138c18e80567737667f55d3f9817ce4714c91d1adfd36101141829dc0b5ea0c4944668c0005ddb6f9e2718f60014f21932a42a36ffaf58e88e77b217b2af366c15dd59e6b136ca773729832dcfc5875ec0830d04012dd5a4fa77a196646ea2b356289116fd02558c034b62d63f8a65bdd20d7ffc3fec6c266cd974be776a9e92759b90f288dcc2525b6b6bd5622c5f02e0922440e9ad1095c19b4467fd94566caa9755669d8e0000000180800000000400f64081ae6209dce9245753a4f764d6f168aae1af00000000000000000000000000000064000041dbcc7391991c1a18371eb49b879240247a3ec7f281328f53976c1218ffd65421dbb101e59370e2c972b29f48dc674b2de5e1b65acbd41d5d2689124d42c16c01010000000000051a346048df62be3a52bb6236e11394e8600229e27b000000000000271000000000000000000000000000000000000000000000000000000000000000000000",
                 *       "chain_id": 2147483648
                 *     } */
                "application/json": unknown;
            };
        };
        responses: {
            /** @description Block proposal has been accepted for processing. The result will be returned via the event observer. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Request not over loopback interface */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description There is an ongoing proposal validation being processed, the new request cannot be accepted until the prior request has been processed. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_stacker_set: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description reward cycle number */
                cycle_number: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Information for the given reward cycle */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Could not fetch the given reward set */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_block_v3: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The block's ID hash */
                block_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The raw SIP-003-encoded block will be returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description The block could not be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/text-plain": unknown;
                };
            };
        };
    };
    get_tenure_info: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metadata about the ongoing tenure */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_tenures: {
        parameters: {
            query?: {
                /** @description The block ID hash of the highest block in this tenure that is already known to the caller.  Neither the corresponding block nor any of its ancestors will be served.  This is used to fetch tenure blocks that the caller does not have. */
                stop?: string;
            };
            header?: never;
            path: {
                /** @description The tenure-start block ID of the tenure to query */
                block_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SIP-003-encoded Nakamoto blocks, concatenated together */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
        };
    };
}
